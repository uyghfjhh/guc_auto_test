# 测试用例编写指南

## 1. 项目结构

```
guc_auto_test/
├── src/test/java/com/fbasecman/guc/
│   ├── GucSyncScenarioTest.java        # 主测试类
│   ├── config/
│   │   └── DatabaseConfig.java         # 数据库配置
│   ├── model/
│   │   └── TestResult.java             # 测试结果模型
│   └── util/
│       └── TablePrinter.java           # 表格打印工具
├── src/test/resources/
│   ├── db.properties                   # 数据库连接配置（需自行创建）
│   └── db.properties.template          # 配置模板
└── doc/
    ├── guc参数测试用例.md               # 测试用例设计文档
    ├── 协议说明.md                      # PostgreSQL协议说明
    └── 测试用例编写指南.md              # 本文档
```

## 2. 测试用例编写规范

### 2.1 测试用例设计原则

每个测试用例应该：
1. **对应一个测试类别**：例如"测试非guc report参数同步"
2. **包含多个检测点**：每个检测点验证一个具体的行为
3. **支持多协议测试**：Simple协议和Extended协议都要测试
4. **清晰的日志输出**：标明客户端连接号、执行的SQL、检测点说明

### 2.2 代码结构

```java
// 1. 为每个协议创建独立的测试方法
public void testCaseX_Description_SimpleProtocol() throws SQLException {
    executeTestCaseX(false, "Simple协议");
}

public void testCaseX_Description_ExtendedProtocol() throws SQLException {
    executeTestCaseX(true, "Extended协议");
}

// 2. 核心逻辑统一实现
private void executeTestCaseX(boolean useExtendedProtocol, String protocolName) {
    // 记录各个检测点的结果
    boolean allPassed = true;
    StringBuilder failureDetails = new StringBuilder();
    
    try {
        // ... 测试步骤 ...
        
        // 每个检测点检查
        if (!检测结果) {
            allPassed = false;
            failureDetails.append("检测点X失败; ");
        }
        
        // 最后统一记录测试结果（一个用例一个协议只记录一次）
        recordResult("测试类别", 
                    "参数名称（" + protocolName + "）", 
                    "所有检测点通过", 
                    allPassed ? "所有检测点通过" : failureDetails.toString(), 
                    allPassed, 
                    allPassed ? "通过" : "失败");
    } finally {
        // 清理资源
    }
}
```

### 2.3 测试结果记录规则

**重要**：每个协议的测试只记录一次总体结果，不要为每个检测点单独记录。

```java
// ✗ 错误做法：每个检测点都记录
recordResult("用例1-Simple协议-检测点1", ...);  // 不要这样做
recordResult("用例1-Simple协议-检测点2", ...);  // 不要这样做

// ✓ 正确做法：整个用例只记录一次
recordResult("测试非guc report参数同步",        // 测试类别（对应文档中的测试类别）
            "extra_float_digits参数（Simple协议）", // 测试用例名称
            "所有检测点通过",                     // 期望结果
            allPassed ? "所有检测点通过" : failureDetails.toString(), 
            allPassed,                            // 是否通过
            allPassed ? "通过" : "失败");         // 备注
```

### 2.4 检测点编写规范

每个检测点应该：

```java
// 【检测点X】说明检测点目的
boolean checkResult = ... // 执行检测逻辑

System.out.println("\n" + "─".repeat(100));
System.out.println("【检测点X】检查XXX:");
System.out.println("  说明: 为什么要检查这个");
System.out.println("  期望: 期望的结果");
System.out.println("  实际: 实际观察到的结果");
if (checkResult) {
    System.out.println(GREEN + "  结果: ✓ 通过 - 具体说明" + RESET);
} else {
    System.out.println(RED + "  结果: ✗ 失败 - 具体说明" + RESET);
    allPassed = false;
    failureDetails.append("检测点X失败; ");
}
System.out.println("─".repeat(100) + "\n");
```

## 3. 协议控制说明

### 3.1 当前实现方式

目前通过 `useExtendedProtocol` 参数控制：
- `true`: 使用 `PreparedStatement` (通常使用Extended协议)
- `false`: 使用 `Statement` (通常使用Simple协议)

### 3.2 更可靠的协议控制方式

**建议**：通过DSN连接参数明确指定协议：

```java
// 方式1：在 db.properties 中配置
db.url=jdbc:postgresql://host:port/db?preferQueryMode=simple     // 强制Simple协议
db.url=jdbc:postgresql://host:port/db?preferQueryMode=extended   // 强制Extended协议

// 方式2：在代码中动态拼接
String url = DatabaseConfig.getUrl() + "?preferQueryMode=simple";
Connection conn = DriverManager.getConnection(url, user, password);
```

**PostgreSQL JDBC 协议模式**：
- `preferQueryMode=simple`: 强制使用Simple Query Protocol
- `preferQueryMode=extended`: 强制使用Extended Query Protocol  
- `preferQueryMode=extendedForPrepared`: 只对PreparedStatement使用Extended（默认）

### 3.3 未来改进建议

建议修改 `DatabaseConfig.java`，支持协议参数：

```java
public static String getUrl(String protocol) {
    String baseUrl = props.getProperty("db.url");
    if (protocol != null && !protocol.isEmpty()) {
        return baseUrl + (baseUrl.contains("?") ? "&" : "?") + 
               "preferQueryMode=" + protocol;
    }
    return baseUrl;
}
```

## 4. SQL执行辅助方法

### 4.1 执行查询并获取结果

```java
/**
 * 获取GUC参数值
 */
private String getGucValue(Connection conn, String paramName, boolean useExtended) {
    String sql = "SHOW " + paramName;
    if (useExtended) {
        try (PreparedStatement pstmt = conn.prepareStatement(sql);
             ResultSet rs = pstmt.executeQuery()) {
            if (rs.next()) {
                return rs.getString(1);
            }
        }
    } else {
        try (Statement stmt = conn.createStatement();
             ResultSet rs = stmt.executeQuery(sql)) {
            if (rs.next()) {
                return rs.getString(1);
            }
        }
    }
    return null;
}
```

### 4.2 执行更新语句

```java
/**
 * 执行更新语句
 */
private void executeUpdate(Connection conn, String sql, boolean useExtended) {
    if (useExtended) {
        try (PreparedStatement pstmt = conn.prepareStatement(sql)) {
            pstmt.execute();
        }
    } else {
        try (Statement stmt = conn.createStatement()) {
            stmt.execute(sql);
        }
    }
}
```

### 4.3 打印SQL日志

```java
/**
 * 打印SQL命令（红色）
 */
private void printSql(int clientId, String sql, String protocol) {
    System.out.println(RED + "[客户端连接" + clientId + " - " + protocol + "] SQL: " + sql + RESET);
}
```

## 5. 添加新测试用例步骤

### 5.1 在文档中设计测试用例

在 `doc/guc参数测试用例.md` 中添加：

```markdown
## 2.X 测试类别：测试XXX

### 2.X.1 测试用例X：参数名称
（1）客户端连接1中执行：
```sql
-- SQL步骤
-- 检测点：说明
```

（2）客户端连接2中执行：
```sql
-- SQL步骤  
-- 检测点：说明
```
```

### 5.2 在代码中实现测试用例

在 `GucSyncScenarioTest.java` 中添加：

```java
// 1. 在 runAllTests() 中调用新测试
public void runAllTests() {
    try {
        // ... 已有测试 ...
        
        // 新测试
        testCaseX_Description_SimpleProtocol();
        testCaseX_Description_ExtendedProtocol();
        
    } catch (Exception e) {
        e.printStackTrace();
    }
    
    TablePrinter.printResults(testResults);
}

// 2. 添加测试方法
public void testCaseX_Description_SimpleProtocol() throws SQLException {
    System.out.println("\n" + "=".repeat(100));
    System.out.println("【用例X-Simple协议】测试XXX");
    System.out.println("=".repeat(100) + "\n");
    executeTestCaseX(false, "Simple协议");
}

public void testCaseX_Description_ExtendedProtocol() throws SQLException {
    System.out.println("\n" + "=".repeat(100));
    System.out.println("【用例X-Extended协议】测试XXX");
    System.out.println("=".repeat(100) + "\n");
    executeTestCaseX(true, "Extended协议");
}

// 3. 实现核心逻辑
private void executeTestCaseX(boolean useExtendedProtocol, String protocolName) 
        throws SQLException {
    Connection conn1 = null;
    Connection conn2 = null;
    
    boolean allPassed = true;
    StringBuilder failureDetails = new StringBuilder();
    
    try {
        // 步骤1：连接1执行...
        System.out.println(YELLOW + "步骤1：..." + RESET);
        conn1 = DriverManager.getConnection(
            DatabaseConfig.getUrl(),
            DatabaseConfig.getUser(),
            DatabaseConfig.getPassword()
        );
        
        // ... 执行SQL和检测 ...
        
        // 检测点1
        boolean check1 = ...;
        System.out.println("【检测点1】...");
        if (!check1) {
            allPassed = false;
            failureDetails.append("检测点1失败; ");
        }
        
        // ... 更多检测点 ...
        
        // 记录最终结果
        recordResult("测试类别名称", 
                    "具体参数（" + protocolName + "）",
                    "所有检测点通过",
                    allPassed ? "所有检测点通过" : failureDetails.toString(),
                    allPassed,
                    allPassed ? "通过" : "失败");
        
    } finally {
        if (conn1 != null) {
            try { conn1.close(); } catch (SQLException e) { e.printStackTrace(); }
        }
        if (conn2 != null) {
            try { conn2.close(); } catch (SQLException e) { e.printStackTrace(); }
        }
    }
}
```

## 6. 表格显示说明

### 6.1 表格结构

表格有3列：
- **测试用例类别**（32字符宽度）：例如"测试非guc report参数同步"
- **测试用例名称**（42字符宽度）：例如"extra_float_digits参数（Simple协议）"
- **结果**（8字符宽度）：✓ 通过 或 ✗ 失败

### 6.2 中文对齐处理

`TablePrinter.java` 中的 `padChinese()` 方法会自动处理中文字符对齐：
- 中文字符占2个字符宽度
- 英文字符占1个字符宽度
- 自动填充空格使列对齐

## 7. 事务管理注意事项

### 7.1 事务提交规则

根据测试需要决定是否提交事务：

```java
// 场景1：需要释放后端连接
conn.commit();  // 提交事务，后端连接返回连接池

// 场景2：需要保持后端连接被占用
// 不提交事务，后端连接继续被当前客户端连接占用
// 注意：必须在 finally 中关闭连接，避免资源泄露
```

### 7.2 测试用例1的事务管理示例

```java
// 步骤1：连接1设置参数后提交
conn1.commit();  // 释放后端连接

// 步骤2：连接2复用后端连接
conn2.setAutoCommit(false);
// 执行检测...
// 注意：这里不提交！保持后端连接被占用

// 步骤3：连接1继续执行
conn1.setAutoCommit(false);
// 因为原后端被占用，会分配新后端连接
conn1.commit();  // 提交后释放新后端连接
```

## 8. 运行测试

### 8.1 配置数据库连接

复制模板文件：
```bash
cp src/test/resources/db.properties.template src/test/resources/db.properties
```

修改配置：
```properties
db.url=jdbc:postgresql://your-host:your-port/your-db
db.user=your-user
db.password=your-password
```

### 8.2 编译运行

```bash
# 编译
mvn clean compile test-compile

# 运行测试
mvn test -Dtest=GucSyncScenarioTest

# 或直接运行main方法
java -cp target/test-classes:target/classes com.fbasecman.guc.GucSyncScenarioTest
```

## 9. 常见问题

### 9.1 为什么每个检测点不单独记录结果？

- 表格只显示用例级别的结果，更简洁
- 详细的检测点结果在日志中已经输出
- 便于统计整体通过率

### 9.2 如何确保使用了正确的协议？

建议在PostgreSQL服务端开启日志，观察实际执行的协议：
```sql
-- postgresql.conf
log_statement = 'all'
log_line_prefix = '%t [%p] %u@%d '
```

### 9.3 连接池的影响

如果使用了pgbouncer等连接池：
- 确保配置为transaction模式或session模式
- statement模式可能导致测试行为异常

## 10. 最佳实践

1. **测试隔离**：每个测试用例使用独立的连接，避免相互影响
2. **资源清理**：始终在finally块中关闭连接
3. **日志清晰**：明确标注客户端连接号、执行的SQL、检测点编号
4. **异常处理**：捕获并打印异常，避免一个用例失败影响其他用例
5. **参数化**：使用变量存储期望值，便于修改和维护
6. **文档同步**：代码实现要与测试用例文档保持一致

## 11. 示例参考

完整示例请参考：
- `GucSyncScenarioTest.java` 中的 `executeTestCase1()` 方法
- `doc/guc参数测试用例.md` 中的用例2.1.1

按照本指南编写的测试用例将自动产生格式统一、对齐美观的测试结果表格。

