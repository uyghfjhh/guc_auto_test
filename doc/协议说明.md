# PostgreSQL查询协议说明

## 两种查询协议对比

### 1. Simple Query Protocol (简单查询协议)

**使用方式：**
```java
Statement stmt = conn.createStatement();
ResultSet rs = stmt.executeQuery("SHOW extra_float_digits");
```

**协议流程：**
```
客户端                                    PostgreSQL服务器
  |                                              |
  |  Query: "SHOW extra_float_digits"           |
  |--------------------------------------------->|
  |                                              | (解析、计划、执行)
  |  RowDescription + DataRow + CommandComplete |
  |<---------------------------------------------|
  |                                              |
```

**特点：**
- ✅ 简单直接，一次性发送完整SQL
- ✅ 适合临时查询和简单语句
- ❌ 不支持参数化查询
- ❌ 每次都需要完整解析SQL
- ❌ 容易受SQL注入攻击

---

### 2. Extended Query Protocol (扩展查询协议)

**使用方式：**
```java
PreparedStatement pstmt = conn.prepareStatement("SHOW extra_float_digits");
ResultSet rs = pstmt.executeQuery();
```

**协议流程：**
```
客户端                                    PostgreSQL服务器
  |                                              |
  |  Parse: "SHOW extra_float_digits"           |
  |--------------------------------------------->|
  |                                              | (解析SQL，生成语句)
  |  ParseComplete                               |
  |<---------------------------------------------|
  |                                              |
  |  Bind: 绑定参数(如有)                        |
  |--------------------------------------------->|
  |                                              | (绑定参数到语句)
  |  BindComplete                                |
  |<---------------------------------------------|
  |                                              |
  |  Execute                                     |
  |--------------------------------------------->|
  |                                              | (执行已准备的语句)
  |  RowDescription + DataRow + CommandComplete |
  |<---------------------------------------------|
  |                                              |
```

**特点：**
- ✅ 支持参数化查询（防SQL注入）
- ✅ 可重复使用已解析的语句
- ✅ 性能更好（重复执行时）
- ✅ 支持批量操作
- ❌ 初次执行开销略大（Parse阶段）

---

## 在GUC参数同步测试中的应用

### 为什么要测试两种协议？

在PostgreSQL连接池（如PgBouncer、FbaseGman等）中，不同协议的处理方式可能不同：

1. **协议解析差异**
   - Simple协议直接发送SQL文本
   - Extended协议分阶段发送（Parse、Bind、Execute）

2. **参数同步时机**
   - Simple协议：在Query消息发送前同步
   - Extended协议：可能在Parse、Bind或Execute阶段同步

3. **连接状态管理**
   - 两种协议的连接状态跟踪可能有差异
   - GUC参数同步机制可能针对不同协议有不同实现

### 测试目标

验证在两种协议下：
- ✅ 后端连接复用是否正常
- ✅ GUC参数重置（RESET）是否正确
- ✅ GUC参数同步（SET）是否正确
- ✅ 连接切换时参数状态是否一致

---

## 代码示例

### Simple Protocol 实现

```java
// 使用Statement执行SQL
private String getGucValue_Simple(Connection conn, String parameter) throws SQLException {
    String sql = "SHOW " + parameter;
    try (Statement stmt = conn.createStatement();
         ResultSet rs = stmt.executeQuery(sql)) {
        if (rs.next()) {
            return rs.getString(1);
        }
    }
    return null;
}
```

### Extended Protocol 实现

```java
// 使用PreparedStatement执行SQL
private String getGucValue_Extended(Connection conn, String parameter) throws SQLException {
    String sql = "SHOW " + parameter;
    try (PreparedStatement pstmt = conn.prepareStatement(sql);
         ResultSet rs = pstmt.executeQuery()) {
        if (rs.next()) {
            return rs.getString(1);
        }
    }
    return null;
}
```

---

## PostgreSQL协议参考

- [PostgreSQL官方文档 - Frontend/Backend Protocol](https://www.postgresql.org/docs/current/protocol.html)
- [Simple Query Protocol](https://www.postgresql.org/docs/current/protocol-flow.html#id-1.10.5.7.4)
- [Extended Query Protocol](https://www.postgresql.org/docs/current/protocol-flow.html#PROTOCOL-FLOW-EXT-QUERY)

